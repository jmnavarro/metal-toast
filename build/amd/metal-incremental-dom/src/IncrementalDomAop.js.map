{"version":3,"sources":["IncrementalDomAop.js"],"names":["IncrementalDomAop","fnStack","fns","originals","getOriginalFns","map","name","value","bind","push","mixin","attr","fnAttr","elementOpenEnd","fnOpenEnd","elementOpenStart","fnOpenStart","elementVoid","fnVoid","length","pop","IncrementalDOM","attributes","symbols","default","elementClose","elementOpen","text","collectedArgs","tag","key","statics","getFn","apply","arguments","handleCall","slice"],"mappings":"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","file":"node_modules/metal-incremental-dom/src/IncrementalDomAop.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { array, object } from 'metal';\n\n/**\n * Class responsible for intercepting incremental dom functions through AOP.\n */\nclass IncrementalDomAop {\n\t/**\n\t * Gets the original functions that are intercepted by `IncrementalDomAop`.\n\t * @return {!Object}\n\t */\n\tstatic getOriginalFns() {\n\t\treturn fnStack[0];\n\t}\n\n\t/**\n\t * Starts intercepting calls to incremental dom, replacing them with the given\n\t * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`\n\t * and `attr` are the only ones that can't be intercepted, since they'll\n\t * automatically be converted into equivalent calls to `elementOpen` and\n\t * `elementClose`.\n\t * @param {!Object} fns Functions to be called instead of the original ones\n\t *     from incremental DOM. Should be given as a map from the function name\n\t *     to the function that should intercept it. All interceptors will receive\n\t *     the original function as the first argument, the actual arguments from\n\t *     from the original call following it.\n\t */\n\tstatic startInterception(fns) {\n\t\tvar originals = IncrementalDomAop.getOriginalFns();\n\t\tfns = object.map(fns, (name, value) => value.bind(null, originals[name]));\n\t\tfnStack.push(object.mixin({}, originals, fns, {\n\t\t\tattr: fnAttr,\n\t\t\telementOpenEnd: fnOpenEnd,\n\t\t\telementOpenStart: fnOpenStart,\n\t\t\telementVoid: fnVoid\n\t\t}));\n\t}\n\n\t/**\n\t * Restores the original `elementOpen` function from incremental dom to the\n\t * implementation it used before the last call to `startInterception`.\n\t */\n\tstatic stopInterception() {\n\t\tif (fnStack.length > 1) {\n\t\t\tfnStack.pop();\n\t\t}\n\t}\n}\n\nvar fnStack = [{\n\tattr: IncrementalDOM.attr,\n\tattributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],\n\telementClose: IncrementalDOM.elementClose,\n\telementOpen: IncrementalDOM.elementOpen,\n\telementOpenEnd: IncrementalDOM.elementOpenEnd,\n\telementOpenStart: IncrementalDOM.elementOpenStart,\n\telementVoid: IncrementalDOM.elementVoid,\n\ttext: IncrementalDOM.text\n}];\n\nvar collectedArgs = [];\n\nfunction fnAttr(name, value) {\n\tcollectedArgs.push(name, value);\n}\n\nfunction fnOpenStart(tag, key, statics) {\n\tcollectedArgs = [tag, key, statics];\n}\n\nfunction fnOpenEnd() {\n\treturn getFn('elementOpen').apply(null, collectedArgs);\n}\n\nfunction fnVoid(tag) {\n\tgetFn('elementOpen').apply(null, arguments);\n\treturn getFn('elementClose')(tag);\n}\n\nfunction getFn(name) {\n\treturn fnStack[fnStack.length - 1][name];\n}\n\nfunction handleCall(name) {\n\treturn getFn(name).apply(null, array.slice(arguments, 1));\n}\n\nIncrementalDOM.attr = handleCall.bind(null, 'attr');\nIncrementalDOM.elementClose = handleCall.bind(null, 'elementClose');\nIncrementalDOM.elementOpen = handleCall.bind(null, 'elementOpen');\nIncrementalDOM.elementOpenEnd = handleCall.bind(null, 'elementOpenEnd');\nIncrementalDOM.elementOpenStart = handleCall.bind(null, 'elementOpenStart');\nIncrementalDOM.elementVoid = handleCall.bind(null, 'elementVoid');\nIncrementalDOM.text = handleCall.bind(null, 'text');\n\nIncrementalDOM.attributes[IncrementalDOM.symbols.default] = handleCall.bind(\n\tnull,\n\t'attributes'\n);\n\nexport default IncrementalDomAop;\n"],"sourceRoot":"/source/"}