{"version":3,"sources":["IncrementalDomRenderer.js"],"names":["IncrementalDomRenderer","comp","context","setConfig_","getInitialConfig","changes_","on","handleAttached_","bind","component_","constructor","SYNC_UPDATES_MERGED","handleStateKeyChanged_","handleInterceptedAttributesCall_","handleInterceptedOpenCall_","handleChildrenCaptured_","handleChildRender_","renderInsidePatchDontSkip_","node","args","wasRendered","attrs","concat","slice","i","length","eventName","getEventFromListenerAttr_","attachEvent_","element","key","fn","handleKey","removeListener","isString","setAttribute","getListenerFn","delegate","document","removeAttribute","children","emptyChildren_","tag","ctor","getConstructor","prefix","currentPrefix_","getUid","count","generatedRefCount_","tagOrCtor","config","ConstructorFn","components","ref","addSubComponent","getRenderer","startSkipUpdates","setState","stopSkipUpdates","parentNode","parent","createElement","append","data","attachData_","originalFn","name","value","isDefAndNotNull","isBoolean","tree","componentToRender_","buildChildren_","prevPrefix_","renderFromTag_","isComponentTag","handleSubComponentCall_","apply","arguments","handleRegularCall_","currComp","getComponentBeingRendered","currRenderer","rootElementReached_","attachDecoratedListeners_","updateElementIfNotReached_","buildConfigFromCall","buildRef","capture","startInterception","attributes","elementOpen","attr","matches","LISTENER_REGEX","exec","toLowerCase","parent_","owner_","patch","child","intercept_","render","stopInterception","prototype","renderSubComponent_","IncrementalDOM","elementVoid","shouldUpdate","currentPointer","skipNode","startedRenderingComponent","schedule","childComponents_","listenersToAttach_","renderIncDom","addElementClasses","emit","isRendered_","finishedRenderingComponent","getSubComponent_","updateContext_","renderer","parentComp","push","renderInsidePatch","console","warn","renderAsSubComponent","prevConfig","isFunction","configChanged","prevVal","newVal","changes","tempParent","guaranteeParent_","exitDocument","inDocument","renderElement_","sibling","patchOuter","hasChangedBesidesElement_","childContext","getChildContext","mixin","renderingComponents_","pop","disposeUnused","CHILD_OWNER","fnOrCtor","opt_dataOrElement","opt_parent","isComponentCtor","TempComponent","RENDERER","renderChild"],"mappings":"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","file":"node_modules/metal-incremental-dom/src/IncrementalDomRenderer.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { core, object } from 'metal';\nimport dom from 'metal-dom';\nimport { Component, ComponentRegistry, ComponentRenderer } from 'metal-component';\nimport IncrementalDomAop from './IncrementalDomAop';\nimport IncrementalDomChildren from './children/IncrementalDomChildren';\nimport IncrementalDomUnusedComponents from './cleanup/IncrementalDomUnusedComponents';\nimport IncrementalDomUtils from './utils/IncrementalDomUtils';\n\n/**\n * Class responsible for rendering components via incremental dom.\n */\nclass IncrementalDomRenderer extends ComponentRenderer {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(comp) {\n\t\tsuper(comp);\n\n\t\tcomp.context = {};\n\t\tthis.setConfig_(comp, comp.getInitialConfig());\n\t\tthis.changes_ = {};\n\t\tcomp.on('attached', this.handleAttached_.bind(this));\n\n\t\tif (!this.component_.constructor.SYNC_UPDATES_MERGED) {\n\t\t\t// If the component is being updated synchronously we'll just reuse the\n\t\t\t// `handleComponentRendererStateKeyChanged_` function from\n\t\t\t// `ComponentRenderer`.\n\t\t\tcomp.on('stateKeyChanged', this.handleStateKeyChanged_.bind(this));\n\t\t}\n\n\t\t// Binds functions that will be used many times, to avoid creating new\n\t\t// functions each time.\n\t\tthis.handleInterceptedAttributesCall_ =\n\t\t\tthis.handleInterceptedAttributesCall_.bind(this);\n\t\tthis.handleInterceptedOpenCall_ =\n\t\t\tthis.handleInterceptedOpenCall_.bind(this);\n\t\tthis.handleChildrenCaptured_ = this.handleChildrenCaptured_.bind(this);\n\t\tthis.handleChildRender_ = this.handleChildRender_.bind(this);\n\t\tthis.renderInsidePatchDontSkip_ = this.renderInsidePatchDontSkip_.bind(this);\n\t}\n\n\t/**\n\t * Attaches inline listeners found on the first component render, since those\n\t * may come from existing elements on the page that already have\n\t * data-on[eventname] attributes set to its final value. This won't trigger\n\t * `handleInterceptedAttributesCall_`, so we need manual work to guarantee\n\t * that projects using progressive enhancement like this will still work.\n\t * @param {!Element} node\n\t * @param {!Array} args\n\t * @protected\n\t */\n\tattachDecoratedListeners_(node, args) {\n\t\tif (!this.component_.wasRendered) {\n\t\t\tvar attrs = (args[2] || []).concat(args.slice(3));\n\t\t\tfor (var i = 0; i < attrs.length; i += 2) {\n\t\t\t\tvar eventName = this.getEventFromListenerAttr_(attrs[i]);\n\t\t\t\tif (eventName && !node[eventName + '__handle__']) {\n\t\t\t\t\tthis.attachEvent_(node, attrs[i], eventName, attrs[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Listens to the specified event, attached via incremental dom calls.\n\t * @param {!Element} element\n\t * @param {string} key\n\t * @param {string} eventName\n\t * @param {function()|string} fn\n\t * @protected\n\t */\n\tattachEvent_(element, key, eventName, fn) {\n\t\tvar handleKey = eventName + '__handle__';\n\t\tif (element[handleKey]) {\n\t\t\telement[handleKey].removeListener();\n\t\t\telement[handleKey] = null;\n\t\t}\n\n\t\telement[key] = fn;\n\t\tif (fn) {\n\t\t\tif (core.isString(fn)) {\n\t\t\t\tif (key[0] === 'd') {\n\t\t\t\t\t// Allow data-on[eventkey] listeners to stay in the dom, as they\n\t\t\t\t\t// won't cause conflicts.\n\t\t\t\t\telement.setAttribute(key, fn);\n\t\t\t\t}\n\t\t\t\tfn = this.component_.getListenerFn(fn);\n\t\t\t}\n\t\t\telement[handleKey] = dom.delegate(document, eventName, element, fn);\n\t\t} else {\n\t\t\telement.removeAttribute(key);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the \"children\" config property to be passed to the current\n\t * component.\n\t * @param {!Array<!Object>} children\n\t * @return {!Array<!Object>}\n\t * @protected\n\t */\n\tbuildChildren_(children) {\n\t\treturn children.length === 0 ? emptyChildren_ : children;\n\t}\n\n\t/**\n\t * Builds the key for the next component that is found.\n\t * @param {string} tag The component's tag.\n\t * @return {string}\n\t */\n\tbuildRef(tag) {\n\t\tvar ctor = core.isString(tag) ? ComponentRegistry.getConstructor(tag) : tag;\n\t\tvar prefix = this.currentPrefix_ + core.getUid(ctor, true);\n\t\tvar count = this.generatedRefCount_[prefix] || 0;\n\t\tthis.generatedRefCount_[prefix] = count + 1;\n\t\treturn prefix + 'sub' + count;\n\t}\n\n\t/**\n\t * Gets the component being currently rendered via `IncrementalDomRenderer`.\n\t * @return {Component}\n\t */\n\tstatic getComponentBeingRendered() {\n\t\treturn renderingComponents_[renderingComponents_.length - 1];\n\t}\n\n\t/**\n\t * Gets the sub component referenced by the given tag and config data,\n\t * creating it if it doesn't yet exist.\n\t * @param {string|!Function} tagOrCtor The tag name.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The sub component.\n\t * @protected\n\t */\n\tgetSubComponent_(tagOrCtor, config) {\n\t\tvar ConstructorFn = tagOrCtor;\n\t\tif (core.isString(ConstructorFn)) {\n\t\t\tConstructorFn = ComponentRegistry.getConstructor(tagOrCtor);\n\t\t}\n\n\t\tvar comp = this.component_.components[config.ref];\n\t\tif (comp && comp.constructor !== ConstructorFn) {\n\t\t\tcomp = null;\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tcomp = new ConstructorFn(config, false);\n\t\t\tthis.component_.addSubComponent(config.ref, comp);\n\t\t}\n\n\t\tif (comp.wasRendered) {\n\t\t\tthis.setConfig_(comp, config);\n\t\t\tcomp.getRenderer().startSkipUpdates();\n\t\t\tcomp.setState(config);\n\t\t\tcomp.getRenderer().stopSkipUpdates();\n\t\t}\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Guarantees that the component's element has a parent. That's necessary\n\t * when calling incremental dom's `patchOuter` for now, as otherwise it will\n\t * throw an error if the element needs to be replaced.\n\t * @return {Element} The parent, in case it was added.\n\t * @protected\n\t */\n\tguaranteeParent_() {\n\t\tvar element = this.component_.element;\n\t\tif (!element || !element.parentNode) {\n\t\t\tvar parent = document.createElement('div');\n\t\t\tif (element) {\n\t\t\t\tdom.append(parent, element);\n\t\t\t}\n\t\t\treturn parent;\n\t\t}\n\t}\n\n\t/**\n\t * Removes the most recent component from the queue of rendering components.\n\t */\n\tstatic finishedRenderingComponent() {\n\t\trenderingComponents_.pop();\n\t\tif (renderingComponents_.length === 0) {\n\t\t\tIncrementalDomUnusedComponents.disposeUnused();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `attached` listener. Stores attach data.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleAttached_(data) {\n\t\tthis.attachData_ = data;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the attributes default handler from\n\t * incremental dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {!Element} element\n\t * @param {string} name\n\t * @param {*} value\n\t * @protected\n\t */\n\thandleInterceptedAttributesCall_(originalFn, element, name, value) {\n\t\tvar eventName = this.getEventFromListenerAttr_(name);\n\t\tif (eventName) {\n\t\t\tthis.attachEvent_(element, name, eventName, value);\n\t\t\treturn;\n\t\t}\n\n\t\tif (name === 'checked') {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"checked\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily check/uncheck the element it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/198 for more details.\n\t\t\tvalue = core.isDefAndNotNull(value) && value !== false;\n\t\t}\n\n\t\tif (name === 'value' && element.value !== value) {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"value\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily update the input's content it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/239 for more details.\n\t\t\t// We only do this if the new value is different though, as otherwise the\n\t\t\t// browser will automatically move the typing cursor to the end of the\n\t\t\t// field.\n\t\t\telement[name] = value;\n\t\t}\n\n\t\tif (core.isBoolean(value)) {\n\t\t\t// Incremental dom sets boolean values as string data attributes, which\n\t\t\t// is counter intuitive. This changes the behavior to use the actual\n\t\t\t// boolean value.\n\t\t\telement[name] = value;\n\t\t\tif (value) {\n\t\t\t\telement.setAttribute(name, '');\n\t\t\t} else {\n\t\t\t\telement.removeAttribute(name);\n\t\t\t}\n\t\t} else {\n\t\t\toriginalFn(element, name, value);\n\t\t}\n\t}\n\n\t/**\n\t * Handles the event of children having finished being captured.\n\t * @param {!Object} The captured children in tree format.\n\t * @protected\n\t */\n\thandleChildrenCaptured_(tree) {\n\t\tvar {config, tag} = this.componentToRender_;\n\t\tconfig.children = this.buildChildren_(tree.config.children);\n\t\tthis.componentToRender_ = null;\n\t\tthis.currentPrefix_ = this.prevPrefix_;\n\t\tthis.prevPrefix_ = null;\n\t\tthis.renderFromTag_(tag, config);\n\t}\n\n\t/**\n\t * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n\t * component nodes so that they can be rendered the correct way without\n\t * having to recapture both them and their children via incremental dom.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t * @protected\n\t */\n\thandleChildRender_(node) {\n\t\tif (node.tag && IncrementalDomUtils.isComponentTag(node.tag)) {\n\t\t\tnode.config.children = this.buildChildren_(node.config.children);\n\t\t\tthis.renderFromTag_(node.tag, node.config);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `stateKeyChanged` event. Overrides original method from\n\t * `ComponentRenderer` to guarantee that `IncrementalDomRenderer`'s logic\n\t * will run first.\n\t * @param {!Object} data\n\t * @override\n\t * @protected\n\t */\n\thandleComponentRendererStateKeyChanged_(data) {\n\t\tthis.handleStateKeyChanged_(data);\n\t\tsuper.handleComponentRendererStateKeyChanged_(data);\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedOpenCall_(originalFn, tag) {\n\t\tif (IncrementalDomUtils.isComponentTag(tag)) {\n\t\t\treturn this.handleSubComponentCall_.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.handleRegularCall_.apply(this, arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a regular element. Adds any inline listeners found and makes\n\t * sure that component root elements are always reused.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleRegularCall_(originalFn, ...args) {\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_ && currComp.config.key) {\n\t\t\targs[1] = currComp.config.key;\n\t\t}\n\n\t\tvar node = originalFn.apply(null, args);\n\t\tthis.attachDecoratedListeners_(node, args);\n\t\tthis.updateElementIfNotReached_(node);\n\t\treturn node;\n\t}\n\n\t/**\n\t * Handles the `stateKeyChanged` event. Stores state properties that have\n\t * changed since the last render.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleStateKeyChanged_(data) {\n\t\tthis.changes_[data.key] = data;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a sub component element. Creates and updates the appropriate\n\t * sub component.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleSubComponentCall_(originalFn, ...args) {\n\t\tvar config = IncrementalDomUtils.buildConfigFromCall(args);\n\t\tconfig.ref = core.isDefAndNotNull(config.ref) ? config.ref : this.buildRef(args[0]);\n\t\tthis.componentToRender_ = {\n\t\t\tconfig,\n\t\t\ttag: args[0]\n\t\t};\n\n\t\tthis.prevPrefix_ = this.currentPrefix_;\n\t\tthis.currentPrefix_ = config.ref;\n\t\tthis.generatedRefCount_[this.currentPrefix_] = 0;\n\t\tIncrementalDomChildren.capture(this, this.handleChildrenCaptured_);\n\t}\n\n\t/**\n\t * Intercepts incremental dom calls from this component.\n\t * @protected\n\t */\n\tintercept_() {\n\t\tIncrementalDomAop.startInterception({\n\t\t\tattributes: this.handleInterceptedAttributesCall_,\n\t\t\telementOpen: this.handleInterceptedOpenCall_\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the given object is an incremental dom node.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t */\n\tstatic isIncDomNode(node) {\n\t\treturn !!node[IncrementalDomChildren.CHILD_OWNER];\n\t}\n\n\t/**\n\t * Returns the event name if the given attribute is a listener (of the form\n\t * \"on<EventName>\"), or null if it isn't.\n\t * @param {string} attr\n\t * @return {?string}\n\t * @protected\n\t */\n\tgetEventFromListenerAttr_(attr) {\n\t\tvar matches = IncrementalDomRenderer.LISTENER_REGEX.exec(attr);\n\t\tvar eventName = matches ? (matches[1] ? matches[1] : matches[2]) : null;\n\t\treturn eventName ? eventName.toLowerCase() : null;\n\t}\n\n\t/**\n\t * Gets the component that is this component's parent (that is, the one that\n\t * actually rendered it), or null if there's no parent.\n\t * @return {Component}\n\t */\n\tgetParent() {\n\t\treturn this.parent_;\n\t}\n\n\t/**\n\t * Gets the component that is this component's owner (that is, the one that\n\t * passed its config properties and holds its ref), or null if there's none.\n\t * @return {Component}\n\t */\n\tgetOwner() {\n\t\treturn this.owner_;\n\t}\n\n\t/**\n\t * Creates and renders the given function, which can either be a simple\n\t * incremental dom function or a component constructor.\n\t * @param {!function()} fnOrCtor Either be a simple incremental dom function\n\t or a component constructor.\n\t * @param {Object|Element=} opt_dataOrElement Optional config data for the\n\t *     function or parent for the rendered content.\n\t * @param {Element=} opt_element Optional parent for the rendered content.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\tstatic render(fnOrCtor, opt_dataOrElement, opt_parent) {\n\t\tif (!Component.isComponentCtor(fnOrCtor)) {\n\t\t\tvar fn = fnOrCtor;\n\t\t\tclass TempComponent extends Component {\n\t\t\t\tcreated() {\n\t\t\t\t\tif (IncrementalDomRenderer.getComponentBeingRendered()) {\n\t\t\t\t\t\tthis.getRenderer().updateContext_(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trender() {\n\t\t\t\t\tfn(this.config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTempComponent.RENDERER = IncrementalDomRenderer;\n\t\t\tfnOrCtor = TempComponent;\n\t\t}\n\t\treturn Component.render(fnOrCtor, opt_dataOrElement, opt_parent);\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`.\n\t */\n\trender() {\n\t\tthis.patch();\n\t}\n\n\t/**\n\t * Renders the given child node via its owner renderer.\n\t * @param {!Object} child\n\t */\n\tstatic renderChild(child) {\n\t\tchild[IncrementalDomChildren.CHILD_OWNER].renderChild(child);\n\t}\n\n\t/**\n\t * Renders the given child node.\n\t * @param {!Object} child\n\t */\n\trenderChild(child) {\n\t\tthis.intercept_();\n\t\tIncrementalDomChildren.render(child, this.handleChildRender_);\n\t\tIncrementalDomAop.stopInterception();\n\t}\n\n\t/**\n\t * Renders the contents for the given tag.\n\t * @param {!function()|string} tag\n\t * @param {!Object} config\n\t * @protected\n\t */\n\trenderFromTag_(tag, config) {\n\t\tif (core.isString(tag) || tag.prototype.getRenderer) {\n\t\t\tvar comp = this.renderSubComponent_(tag, config);\n\t\t\tthis.updateElementIfNotReached_(comp.element);\n\t\t\treturn comp.element;\n\t\t} else {\n\t\t\treturn tag(config);\n\t\t}\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t */\n\trenderIncDom() {\n\t\tif (this.component_.render) {\n\t\t\tthis.component_.render();\n\t\t} else {\n\t\t\tIncrementalDOM.elementVoid('div');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, but\n\t * doesn't call `patch` yet. Rather, this will be the function that should be\n\t * called by `patch`.\n\t */\n\trenderInsidePatch() {\n\t\tif (this.component_.wasRendered &&\n\t\t\t!this.shouldUpdate(this.changes_) &&\n\t\t\tIncrementalDOM.currentPointer() === this.component_.element) {\n\t\t\tif (this.component_.element) {\n\t\t\t\tIncrementalDOM.skipNode();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.renderInsidePatchDontSkip_();\n\t}\n\n\t/**\n\t * The same as `renderInsidePatch`, but without the check that may skip the\n\t * render action.\n\t * @protected\n\t */\n\trenderInsidePatchDontSkip_() {\n\t\tIncrementalDomRenderer.startedRenderingComponent(this.component_);\n\t\tthis.changes_ = {};\n\t\tthis.rootElementReached_ = false;\n\t\tIncrementalDomUnusedComponents.schedule(this.childComponents_ || []);\n\t\tthis.childComponents_ = [];\n\t\tthis.generatedRefCount_ = {};\n\t\tthis.listenersToAttach_ = [];\n\t\tthis.currentPrefix_ = '';\n\t\tthis.intercept_();\n\t\tthis.renderIncDom();\n\t\tIncrementalDomAop.stopInterception();\n\t\tif (!this.rootElementReached_) {\n\t\t\tthis.component_.element = null;\n\t\t} else {\n\t\t\tthis.component_.addElementClasses();\n\t\t}\n\t\tthis.emit('rendered', !this.isRendered_);\n\t\tIncrementalDomRenderer.finishedRenderingComponent();\n\t}\n\n\t/**\n\t * This updates the sub component that is represented by the given data.\n\t * The sub component is created, added to its parent and rendered. If it\n\t * had already been rendered before though, it will only have its state\n\t * updated instead.\n\t * @param {string|!function()} tagOrCtor The tag name or constructor function.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The updated sub component.\n\t * @protected\n\t */\n\trenderSubComponent_(tagOrCtor, config) {\n\t\tvar comp = this.getSubComponent_(tagOrCtor, config);\n\t\tthis.updateContext_(comp);\n\t\tvar renderer = comp.getRenderer();\n\t\tif (renderer instanceof IncrementalDomRenderer) {\n\t\t\tvar parentComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\t\tparentComp.getRenderer().childComponents_.push(comp);\n\t\t\trenderer.parent_ = parentComp;\n\t\t\trenderer.owner_ = this.component_;\n\t\t\trenderer.renderInsidePatch();\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'IncrementalDomRenderer doesn\\'t support rendering sub components ' +\n\t\t\t\t'that don\\'t use IncrementalDomRenderer as well, like:',\n\t\t\t\tcomp\n\t\t\t);\n\t\t}\n\t\tif (!comp.wasRendered) {\n\t\t\tcomp.renderAsSubComponent();\n\t\t}\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Sets the component's config object with its new value.\n\t * @param {!Component} comp The component to set the config for.\n\t * @param {!Object} config\n\t * @protected\n\t */\n\tsetConfig_(comp, config) {\n\t\tvar prevConfig = comp.config;\n\t\tcomp.config = config;\n\t\tif (core.isFunction(comp.configChanged)) {\n\t\t\tcomp.configChanged(config, prevConfig || {});\n\t\t}\n\t\tcomp.emit('configChanged', {\n\t\t\tprevVal: prevConfig,\n\t\t\tnewVal: config\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * Can be overridden by subclasses or implemented by components to provide\n\t * customized behavior (only updating when a state property used by the\n\t * template changes, for example).\n\t * @param {!Object} changes\n\t * @return {boolean}\n\t */\n\tshouldUpdate(changes) {\n\t\tif (this.component_.shouldUpdate) {\n\t\t\treturn this.component_.shouldUpdate(changes);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stores the component that has just started being rendered.\n\t * @param {!Component} comp\n\t */\n\tstatic startedRenderingComponent(comp) {\n\t\trenderingComponents_.push(comp);\n\t}\n\n\t/**\n\t * Patches the component's element with the incremental dom function calls\n\t * done by `renderIncDom`.\n\t */\n\tpatch() {\n\t\tif (!this.component_.element && this.parent_) {\n\t\t\t// If the component has no content but was rendered from another component,\n\t\t\t// we'll need to patch this parent to make sure that any new content will\n\t\t\t// be added in the right place.\n\t\t\tthis.parent_.getRenderer().patch();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tempParent = this.guaranteeParent_();\n\t\tif (tempParent) {\n\t\t\tIncrementalDOM.patch(tempParent, this.renderInsidePatchDontSkip_);\n\t\t\tdom.exitDocument(this.component_.element);\n\t\t\tif (this.component_.element && this.component_.inDocument) {\n\t\t\t\tthis.component_.renderElement_(\n\t\t\t\t\tthis.attachData_.parent,\n\t\t\t\t\tthis.attachData_.sibling\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tvar element = this.component_.element;\n\t\t\tIncrementalDOM.patchOuter(element, this.renderInsidePatchDontSkip_);\n\t\t\tif (!this.component_.element) {\n\t\t\t\tdom.exitDocument(element);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`. Makes\n\t * sure that it won't cause a rerender if the only change was for the\n\t * \"element\" property.\n\t */\n\tupdate() {\n\t\tif (this.hasChangedBesidesElement_(this.changes_) &&\n\t\t\tthis.shouldUpdate(this.changes_)) {\n\t\t\tthis.patch();\n\t\t}\n\t}\n\n\t/**\n\t * Updates this renderer's component's element with the given values, unless\n\t * it has already been reached by an earlier call.\n\t * @param {!Element} node\n\t * @protected\n\t */\n\tupdateElementIfNotReached_(node) {\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_) {\n\t\t\tcurrRenderer.rootElementReached_ = true;\n\t\t\tif (currComp.element !== node) {\n\t\t\t\tcurrComp.element = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the given component's context according to the data from the\n\t * component that is currently being rendered.\n\t * @param {!Component} comp\n\t * @protected\n\t */\n\tupdateContext_(comp) {\n\t\tvar context = comp.context;\n\t\tvar parent = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar childContext = parent.getChildContext ? parent.getChildContext() : {};\n\t\tobject.mixin(context, parent.context, childContext);\n\t\tcomp.context = context;\n\t}\n}\n\nvar renderingComponents_ = [];\nvar emptyChildren_ = [];\n\nIncrementalDomRenderer.LISTENER_REGEX = /^(?:on([A-Z]\\w+))|(?:data-on(\\w+))$/;\n\nexport default IncrementalDomRenderer;\n"],"sourceRoot":"/source/"}