{"version":3,"sources":["Config.js"],"names":["Config","required","mergeConfig","setter","validator","value","context","config","obj","Object","create","mixin","fnNames","keys","forEach","name"],"mappings":";AAAA;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,KAAMA,SAAS;AAMdC,UANc,sBAMY;AAAA,OAAjBA,SAAiB,uEAAN,IAAM;;AACzB,UAAOC,YAAY,IAAZ,EAAkB,EAACD,mBAAD,EAAlB,CAAP;AACA,GARa;AAedE,QAfc,kBAePA,OAfO,EAeC;AACd,UAAOD,YAAY,IAAZ,EAAkB,EAACC,eAAD,EAAlB,CAAP;AACA,GAjBa;AAwBdC,WAxBc,qBAwBJA,UAxBI,EAwBO;AACpB,UAAOF,YAAY,IAAZ,EAAkB,EAACE,qBAAD,EAAlB,CAAP;AACA,GA1Ba;AAiCdC,OAjCc,iBAiCRA,MAjCQ,EAiCD;AACZ,UAAOH,YAAY,IAAZ,EAAkB,EAACG,aAAD,EAAlB,CAAP;AACA;AAnCa,EAAf;;AAsCA;;;;;;AAMA,UAASH,WAAT,CAAqBI,OAArB,EAA8BC,MAA9B,EAAsC;AACrC,MAAIC,MAAMF,OAAV;AACA,MAAIE,QAAQR,MAAZ,EAAoB;AACnBQ,SAAMC,OAAOC,MAAP,CAAcV,MAAd,CAAN;AACAQ,OAAID,MAAJ,GAAa,EAAb;AACA;AACD,gBAAOI,KAAP,CAAaH,IAAID,MAAjB,EAAyBA,MAAzB;AACA,SAAOC,GAAP;AACA;;AAED;AACA,KAAII,UAAUH,OAAOI,IAAP,sBAAd;AACAD,SAAQE,OAAR,CACC;AAAA,SAAQd,OAAOe,IAAP,IAAe,YAAW;AACjC,UAAO,KAAKX,SAAL,CAAe,qBAAWW,IAAX,CAAf,CAAP;AACA,GAFD;AAAA,EADD;;mBAMef,M","file":"node_modules/metal-state/src/Config.js","sourcesContent":["'use strict';\n\nimport { object } from 'metal';\nimport validators from './validators';\n\n/**\n * Sugar api that can be used as an alternative for manually building `State`\n * configuration in the expected format. For example, instead of having\n * something like this:\n *\n * ```js\n * MyClass.STATE = {\n *   foo: {\n *     required: true,\n *     validator: validators.number,\n *     value: 13\n *   }\n * };\n * ```\n *\n * You could instead do:\n *\n * ```js\n * MyClass.STATE = {\n *   foo: Config.required().number().value(13)\n * };\n * ```\n */\nconst Config = {\n\t/**\n\t * Adds the `required` flag to the `State` configuration.\n\t * @param {boolean} required Flag to set \"required\" to. True by default.\n\t * @return {!Object} `State` configuration object.\n\t */\n\trequired(required = true) {\n\t\treturn mergeConfig(this, {required});\n\t},\n\n\t/**\n\t * Adds a setter to the `State` configuration.\n\t * @param {!function()} setter\n\t * @return {!Object} `State` configuration object.\n\t */\n\tsetter(setter) {\n\t\treturn mergeConfig(this, {setter});\n\t},\n\n\t/**\n\t * Adds a validator to the `State` configuration.\n\t * @param {!function()} validator\n\t * @return {!Object} `State` configuration object.\n\t */\n\tvalidator(validator) {\n\t\treturn mergeConfig(this, {validator});\n\t},\n\n\t/**\n\t * Adds a default value to the `State` configuration.\n\t * @param {*} value\n\t * @return {!Object} `State` configuration object.\n\t */\n\tvalue(value) {\n\t\treturn mergeConfig(this, {value});\n\t}\n};\n\n/**\n * Merges the given config object into the one that has been built so far.\n * @param {!Object} context The object calling this function.\n * @param {!Object} config The object to merge to the built config.\n * @return {!Object} The final object containing the built config.\n */\nfunction mergeConfig(context, config) {\n\tvar obj = context;\n\tif (obj === Config) {\n\t\tobj = Object.create(Config);\n\t\tobj.config = {};\n\t}\n\tobject.mixin(obj.config, config);\n\treturn obj;\n}\n\n// Add all validators to `Config`.\nvar fnNames = Object.keys(validators);\nfnNames.forEach(\n\tname => Config[name] = function() {\n\t\treturn this.validator(validators[name]);\n\t}\n);\n\nexport default Config;\n"],"sourceRoot":"/source/"}