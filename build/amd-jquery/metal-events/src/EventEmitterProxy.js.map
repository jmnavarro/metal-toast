{"version":3,"sources":["EventEmitterProxy.js"],"names":["EventEmitterProxy","originEmitter","targetEmitter","opt_blacklist","opt_whitelist","blacklist_","originEmitter_","pendingEvents_","proxiedEvents_","targetEmitter_","whitelist_","startProxy_","event","listener","on","addListener_","emitOnTarget_","bind","removeListeners_","eventType","args","concat","slice","arguments","emit","apply","shouldProxyEvent_","tryToAddListener_","events","Object","keys","i","length","removeListener","forEach","proxyEvent","addListenerForEvent_","push"],"mappings":"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","file":"node_modules/metal-events/src/EventEmitterProxy.js","sourcesContent":["'use strict';\n\nimport { array, Disposable } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist || {};\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * A list of events that are pending to be listened by an actual origin\n\t\t * emitter. Events are stored here when the origin doesn't exist, so they\n\t\t * can be set on a new origin when one is set.\n\t\t * @type {!Array}\n\t\t * @protected\n\t\t */\n\t\tthis.pendingEvents_ = [];\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object<string, !EventHandle>}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = {};\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the given listener for the given event.\n\t * @param {string} event\n\t * @param {!function()} listener\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListener_(event, listener) {\n\t\treturn this.originEmitter_.on(event, listener);\n\t}\n\n\t/**\n\t * Adds the proxy listener for the given event.\n\t * @param {string} event\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListenerForEvent_(event) {\n\t\treturn this.addListener_(event, this.emitOnTarget_.bind(this, event));\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.removeListeners_();\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Emits the specified event type on the target emitter.\n\t * @param {string} eventType\n\t * @protected\n\t */\n\temitOnTarget_(eventType) {\n\t\tvar args = [eventType].concat(array.slice(arguments, 1));\n\t\tthis.targetEmitter_.emit.apply(this.targetEmitter_, args);\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent(event) {\n\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\tthis.tryToAddListener_(event);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the proxy listener for all events.\n\t * @protected\n\t */\n\tremoveListeners_() {\n\t\tvar events = Object.keys(this.proxiedEvents_);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t}\n\t\tthis.proxiedEvents_ = {};\n\t\tthis.pendingEvents_ = [];\n\t}\n\n\t/**\n\t * Changes the origin emitter. This automatically detaches any events that\n\t * were already being proxied from the previous emitter, and starts proxying\n\t * them on the new emitter instead.\n\t * @param {!EventEmitter} originEmitter\n\t */\n\tsetOriginEmitter(originEmitter) {\n\t\tvar events = this.originEmitter_ ?\n\t\t\tObject.keys(this.proxiedEvents_) :\n\t\t\tthis.pendingEvents_;\n\t\tthis.removeListeners_();\n\t\tthis.originEmitter_ = originEmitter;\n\t\tevents.forEach(event => this.proxyEvent(event));\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.on('newListener', this.proxyEvent.bind(this));\n\t}\n\n\t/**\n\t * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n\t * the pending listener so it can be used on a future origin emitter.\n\t * @param {string} event\n\t * @protected\n\t */\n\ttryToAddListener_(event) {\n\t\tif (this.originEmitter_) {\n\t\t\tthis.proxiedEvents_[event] = this.addListenerForEvent_(event);\n\t\t} else {\n\t\t\tthis.pendingEvents_.push(event);\n\t\t}\n\t}\n}\n\nexport default EventEmitterProxy;\n"],"sourceRoot":"/source/"}